# Two sum
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j]==target:
                    return [i,j]

#Remove duplicates
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
         
        k=1 
        for i in range(1,len(nums)):
            if nums[i]!=nums[i-1]:
                nums[k]=nums[i]
                k+=1 
        return k

# longest common prefix
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        p=strs[0]
        for i in strs[1:]:
            while not i.startswith(p):
                p=p[:-1]
        return p

#remove elements 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0 
        for i in range(len(nums)):
            if val!=nums[i]:
                nums[k]=nums[i]
                k+=1
        return k

#search insert postiion
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l,r=0,len(nums)-1
        for i in range(len(nums)):
            mid=(l+r)//2 
            if nums[mid]==target:
                return mid 
            elif nums[mid]<target:
                l+=1 
            else:
                r-=1 
        return l

#plus one 
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        a=len(digits)
        for i in range(a-1,-1,-1):
            if digits[i]<9:
                digits[i]+=1 
                return digits 
            digits[i]=0 
        return [1]+digits
## merge sorted array 

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        nums1[m:]=nums2 
        print(nums1.sort())
            
#convert sorted into binary search 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums :
            return None 
        mid=len(nums)//2 
        root=TreeNode(nums[mid])
        root.left=self.sortedArrayToBST(nums[:mid])
        root.right=self.sortedArrayToBST(nums[mid+1:])
        return root

# pascal 2 
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        r=[1]
        for i in range(1,rowIndex+1):
            pe=r[i-1]
            ce=pe*(rowIndex-i+1)//i 
            r.append(ce)
        return r
#pascals 1 
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows==0:
            return []
        if numRows==1:
            return [[1]]
        pr=self.generate(numRows-1)
        ps=pr[-1]
        cr=[1]
        for i in range(1,numRows-1):
            cr.append(ps[i-1]+ps[i])
        cr.append(1)
        pr.append(cr)
        return pr
# best time to sell stock 
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        mp=float('inf')
        p=0 
        for i in prices:
            mp=min(mp,i)
            p=max(p,i-mp)
        return p
#find single number 
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        r=0 
        for i in nums:
            r^=i 
        return r 

#max occurance 
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        c=0 
        d=None 
        for i in nums:
            if c==0:
                d=i 
            if i==d:
                c+=1 
            else:
                c-=1 
        return d
#contains duplicate 
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        a=len(nums)
        b=len(set(nums)) 
        if a!=b:
            return True 
        return False
# contains duplicates 2
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        a={}
        for i,j in enumerate (nums):
            if j in a and i-a[j]<=k:
                return True 
            a[j]=i 
        return False
