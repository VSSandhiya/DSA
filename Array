# Two sum
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j]==target:
                    return [i,j]

#Remove duplicates
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
         
        k=1 
        for i in range(1,len(nums)):
            if nums[i]!=nums[i-1]:
                nums[k]=nums[i]
                k+=1 
        return k

# longest common prefix
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        p=strs[0]
        for i in strs[1:]:
            while not i.startswith(p):
                p=p[:-1]
        return p

#remove elements 
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0 
        for i in range(len(nums)):
            if val!=nums[i]:
                nums[k]=nums[i]
                k+=1
        return k

#search insert postiion
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l,r=0,len(nums)-1
        for i in range(len(nums)):
            mid=(l+r)//2 
            if nums[mid]==target:
                return mid 
            elif nums[mid]<target:
                l+=1 
            else:
                r-=1 
        return l

#plus one 
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        a=len(digits)
        for i in range(a-1,-1,-1):
            if digits[i]<9:
                digits[i]+=1 
                return digits 
            digits[i]=0 
        return [1]+digits
## merge sorted array 

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        nums1[m:]=nums2 
        print(nums1.sort())
            
#convert sorted into binary search 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums :
            return None 
        mid=len(nums)//2 
        root=TreeNode(nums[mid])
        root.left=self.sortedArrayToBST(nums[:mid])
        root.right=self.sortedArrayToBST(nums[mid+1:])
        return root

# pascal 2 
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        r=[1]
        for i in range(1,rowIndex+1):
            pe=r[i-1]
            ce=pe*(rowIndex-i+1)//i 
            r.append(ce)
        return r
#pascals 1 
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows==0:
            return []
        if numRows==1:
            return [[1]]
        pr=self.generate(numRows-1)
        ps=pr[-1]
        cr=[1]
        for i in range(1,numRows-1):
            cr.append(ps[i-1]+ps[i])
        cr.append(1)
        pr.append(cr)
        return pr
# best time to sell stock 
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        mp=float('inf')
        p=0 
        for i in prices:
            mp=min(mp,i)
            p=max(p,i-mp)
        return p
#find single number 
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        r=0 
        for i in nums:
            r^=i 
        return r 

#max occurance 
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        c=0 
        d=None 
        for i in nums:
            if c==0:
                d=i 
            if i==d:
                c+=1 
            else:
                c-=1 
        return d
#contains duplicate 
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        a=len(nums)
        b=len(set(nums)) 
        if a!=b:
            return True 
        return False
# contains duplicates 2
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        a={}
        for i,j in enumerate (nums):
            if j in a and i-a[j]<=k:
                return True 
            a[j]=i 
        return False
#missing elements 
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        a=len(nums)
        b=a*(a+1)//2 
        return b-sum(nums)
#intersection of two list 
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        a=set(nums1)
        b=set(nums2)
        return list(a&b)
#intersection of two aray 2
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        r=[]
        a=nums2.copy()
        for i in nums1:
            if i in a:
                r.append(i)
                a.remove(i)
        return r
#find 3rd max elemeent 
class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        a=set(nums)
        if len(a)<3:
            return max(a)
        a.remove(max(a))
        a.remove(max(a))
        return max(a)

#find all number disappered element 
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        s=set(nums)
        r=[]
        for i in range(1,len(nums)+1):
            if i not in s:
                r.append(i)
        return r
#accept cookies 
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i=0 
        j=0 
        c=0 
        while i<len(g) and j<len(s):
            if s[j]>=g[i]:
                c+=1 
                i+=1 
                j+=1 
            else:
                j+=1 
        return c
#island perimeter 
class Solution:
    def islandPerimeter(self, grid):
        p = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if i == 0 or grid[i-1][j] == 0:
                        p += 1
                    if i == len(grid)-1 or grid[i+1][j] == 0:
                        p += 1
                    if j == 0 or grid[i][j-1] == 0:
                        p += 1
                    if j == len(grid[0])-1 or grid[i][j+1] == 0:
                        p += 1
        return p
#max consecutive one 
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        c=0 
        d=0 
        for i in nums:
            if i==1:
                d+=1 
                c=max(c,d)
            else:
                d=0 
        return c

